<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Simeon's Blog</title>
		<description>A minimal blog for iOS, Android coding issues.</description>
		<link>/</link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>targetViewController</title>
				<description>&lt;p&gt;There is a senario where that we have view controller A, and A presents view controller B, then B presents C view controllers, and so on, this will form a view controller hierarchy. At a certain point, we may want to pass one piece of data from a far away child view controller, C for example, back to parent controller A. How do we do that?&lt;/p&gt;

&lt;p&gt;I can think several solutions here:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Delegate&lt;/li&gt;
  &lt;li&gt;Notification&lt;/li&gt;
  &lt;li&gt;Reactive&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Apart from these, there is one more that I think could be used here.
Since iOS 8, Appple introduce a new method called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;targetViewController(forAction:sender:)&lt;/code&gt;,
Apple document describes this methos as:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;This method returns the current view controller if that view controller overrides the method indicated by the action parameter. If the current view controller does not override that method, UIKit walks up the view hierarchy and returns the first view controller that does override it. If no view controller handles the action, this method returns nil.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As it said this method basically just trace up the view controller hierarchy to find a proper receiver for the action. Letâ€™s see how to pass data back to parent by code.&lt;/p&gt;

&lt;p&gt;First we have a controller A and its child view controller B, C, in C there is an action that will trigger the data passing back:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class AViewController: UIViewController, TrackingUp {
   
       @IBAction func next(_ sender: Any) {
        let vc = BViewController()
        addChild(vc)
        view.addSubview(vc.view)
        vc.didMove(toParent: self)
      ...
    }
}
class BViewController: UIViewController {

    @IBAction func next(_ sender: Any) {
        let vc = CViewController()
        self.show(vc, sender: nil)
        addChild(vc)
        view.addSubview(vc.view)
    ...
    }
}
class CViewController: UIViewController {
    
    @IBAction func clickeAction(_ sender: UIButton) {
    
        // do some thing here
    }
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Then define an selector method:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@objc protocol TrackingUp: NSObjectProtocol {
    func didSelected(index: NSNumber)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Note: the protocol has be anotated by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@objc&lt;/code&gt;, so it is Objective-C visible.&lt;/strong&gt;
In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clickAction&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    
      @IBAction func clickeAction(_ sender: UIButton) {
    
        let selector = #selector(TrackingUp.didSelected(index:))
        guard let target = self.targetViewController(forAction: selector, sender: sender)  else { return } // 1
        target.perform(selector, with: 1)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;line 1 is the magic happen, by calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;targetViewController&lt;/code&gt;, UIKit will trace up the hierarchy for us, so we just need to override &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;targetViewController&lt;/code&gt; in the view controller A  you want to received that piece of data.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   override func targetViewController(forAction action: Selector, sender: Any?) -&amp;gt; UIViewController? {
        let selector = #selector(TrackingUp.didSelected(index:))
        if action == selector {
            return self
        }
        return super.targetViewController(forAction: action, sender: sender)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Of cause we also need to impletement the protocol method in C controller:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension AViewController: TrackingUp {
    func didSelected(index: NSNumber) {
        print(&quot;A: selected \(index)&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;summary&quot;&gt;summary&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Pro&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Use this method we can avoid to pass around delegate objects or introducing other reactive libraries.&lt;/li&gt;
    &lt;li&gt;It also stick to build in UIKit which all iOS developers are familiar with.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Con&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;You have to expose functions to Objective-C and use Objective-C runtime.&lt;/li&gt;
    &lt;li&gt;In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;performSelector:(SEL)aSelector withObject:(id)object&lt;/code&gt; function argument object lost type information(e.g. an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;), that is why the argument type defined in protocol &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;didSelected(index: NSNumber)&lt;/code&gt; method is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSNumber&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;The child view controllers have to know what kind of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;selector&lt;/code&gt; need to be checked, leaking unneeded details.&lt;/li&gt;
    &lt;li&gt;If the final received view controller is container controller like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationViewController&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TabViewController&lt;/code&gt; then you may have to subclass your own container controller in order to override &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;targetViewController&lt;/code&gt; function.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;Here is another good article regarding &lt;a href=&quot;https://sandofsky.com/patterns/controller-hierarchies/&quot;&gt;ViewController Hierarchies&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/simeonlu/2d544ee1999e310836c6c7b5041f7393&quot;&gt;gist&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Tue, 20 Apr 2021 00:00:00 +0800</pubDate>
				<link>/2021/04/20/targetViewController.html</link>
				<guid isPermaLink="true">/2021/04/20/targetViewController.html</guid>
			</item>
		
	</channel>
</rss>
